"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/comma-number";
exports.ids = ["vendor-chunks/comma-number"];
exports.modules = {

/***/ "(rsc)/./node_modules/comma-number/index.js":
/*!********************************************!*\
  !*** ./node_modules/comma-number/index.js ***!
  \********************************************/
/***/ ((module) => {

eval("\n// return a string with the provided number formatted with commas.\n// can specify either a Number or a String.\nfunction commaNumber(inputNumber, optionalSeparator, optionalDecimalChar) {\n    // default `decimalChar` is a period\n    const decimalChar = optionalDecimalChar || \".\";\n    let stringNumber // we assign this in the switch block and need it later.\n    ;\n    {\n        let number // we assign this in the switch block and need it right after.\n        ;\n        switch(typeof inputNumber){\n            case \"string\":\n                // if there aren't enough digits to need separators then return it\n                // NOTE: some numbers which are too small will get passed this\n                //       when they have decimal values which make them too long here.\n                //       but, the number value check after this switch will catch it.\n                if (inputNumber.length < (inputNumber[0] === \"-\" ? 5 : 4)) {\n                    return inputNumber;\n                }\n                // remember it as a string in `stringNumber` and convert to a Number\n                stringNumber = inputNumber;\n                // if they're not using the Node standard decimal char then replace it\n                // before converting.\n                number = Number(decimalChar !== \".\" ? stringNumber.replace(decimalChar, \".\") : stringNumber);\n                break;\n            // convert to a string.\n            // NOTE: don't check if the number is too small before converting\n            //       because we'll need to return `stringNumber` anyway.\n            case \"number\":\n                stringNumber = String(inputNumber);\n                number = inputNumber;\n                // create the string version with the decimalChar they specified.\n                // this matches what the above case 'string' produces,\n                // and, fixes the bug *not* doing this caused.\n                if (\".\" !== decimalChar && !Number.isInteger(inputNumber)) {\n                    stringNumber = stringNumber.replace(\".\", decimalChar);\n                }\n                break;\n            // return invalid type as-is\n            default:\n                return inputNumber;\n        }\n        // when it doesn't need a separator or isn't a number then return it\n        if (-1000 < number && number < 1000 || isNaN(number) || !isFinite(number)) {\n            return stringNumber;\n        }\n    }\n    {\n        // strip off decimal value to add back in later\n        const decimalIndex = stringNumber.lastIndexOf(decimalChar);\n        let decimal;\n        if (decimalIndex > -1) {\n            decimal = stringNumber.slice(decimalIndex);\n            stringNumber = stringNumber.slice(0, decimalIndex);\n        }\n        // finally, parse the string. Note, default 'separator' is a comma.\n        const parts = parse(stringNumber, optionalSeparator || \",\");\n        // if there's a decimal value then add it to the parts.\n        if (decimal) {\n            parts.push(decimal);\n        }\n        // combine all parts for the final string (note, has separators).\n        return parts.join(\"\");\n    }\n}\nfunction parse(string, separator) {\n    // find first index to split the string at (where 1st separator goes).\n    let i = (string.length - 1) % 3 + 1;\n    // above calculation is wrong when num is negative and a certain size.\n    if (i === 1 && string[0] === \"-\") {\n        i = 4 // example: -123,456,789  start at 4, not 1.\n        ;\n    }\n    const strings = [\n        string.slice(0, i) // grab part before the first separator\n    ];\n    // split remaining string in groups of 3 where a separator belongs\n    for(; i < string.length; i += 3){\n        strings.push(separator, string.substr(i, 3));\n    }\n    return strings;\n}\n// convenience function for currying style:\n//   const format = commaNumber.bindWith(',', '.')\nfunction bindWith(separator, decimalChar) {\n    return function(number) {\n        return commaNumber(number, separator, decimalChar);\n    };\n}\nmodule.exports = commaNumber;\nmodule.exports.bindWith = bindWith;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY29tbWEtbnVtYmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsa0VBQWtFO0FBQ2xFLDJDQUEyQztBQUMzQyxTQUFTQSxZQUFZQyxXQUFXLEVBQUVDLGlCQUFpQixFQUFFQyxtQkFBbUI7SUFFdEUsb0NBQW9DO0lBQ3BDLE1BQU1DLGNBQWNELHVCQUF1QjtJQUUzQyxJQUFJRSxhQUFhLHdEQUF3RDs7SUFFekU7UUFDRSxJQUFJQyxPQUFPLDhEQUE4RDs7UUFFekUsT0FBUSxPQUFPTDtZQUViLEtBQUs7Z0JBRUgsa0VBQWtFO2dCQUNsRSw4REFBOEQ7Z0JBQzlELHFFQUFxRTtnQkFDckUscUVBQXFFO2dCQUNyRSxJQUFJQSxZQUFZTSxNQUFNLEdBQUlOLENBQUFBLFdBQVcsQ0FBQyxFQUFFLEtBQUssTUFBTSxJQUFJLElBQUk7b0JBQ3pELE9BQU9BO2dCQUNUO2dCQUVBLG9FQUFvRTtnQkFDcEVJLGVBQWVKO2dCQUVmLHNFQUFzRTtnQkFDdEUscUJBQXFCO2dCQUNyQkssU0FBU0UsT0FDUCxnQkFBaUIsTUFBT0gsYUFBYUksT0FBTyxDQUFDTCxhQUFhLE9BQU9DO2dCQUVuRTtZQUVGLHVCQUF1QjtZQUN2QixpRUFBaUU7WUFDakUsNERBQTREO1lBQzVELEtBQUs7Z0JBQ0hBLGVBQWVLLE9BQU9UO2dCQUN0QkssU0FBZUw7Z0JBQ2YsaUVBQWlFO2dCQUNqRSxzREFBc0Q7Z0JBQ3RELDhDQUE4QztnQkFDOUMsSUFBSSxRQUFRRyxlQUFlLENBQUNJLE9BQU9HLFNBQVMsQ0FBQ1YsY0FBYztvQkFDekRJLGVBQWVBLGFBQWFJLE9BQU8sQ0FBQyxLQUFLTDtnQkFDM0M7Z0JBQ0E7WUFFRiw0QkFBNEI7WUFDNUI7Z0JBQVMsT0FBT0g7UUFDbEI7UUFFQSxvRUFBb0U7UUFDcEUsSUFBSSxDQUFFLE9BQU9LLFVBQVVBLFNBQVMsUUFBU00sTUFBTU4sV0FBVyxDQUFDTyxTQUFTUCxTQUFTO1lBQzNFLE9BQU9EO1FBQ1Q7SUFDRjtJQUVBO1FBQ0UsK0NBQStDO1FBQy9DLE1BQU1TLGVBQWVULGFBQWFVLFdBQVcsQ0FBQ1g7UUFDOUMsSUFBSVk7UUFDSixJQUFJRixlQUFlLENBQUMsR0FBRztZQUNyQkUsVUFBVVgsYUFBYVksS0FBSyxDQUFDSDtZQUM3QlQsZUFBZUEsYUFBYVksS0FBSyxDQUFDLEdBQUdIO1FBQ3ZDO1FBRUEsbUVBQW1FO1FBQ25FLE1BQU1JLFFBQVFDLE1BQU1kLGNBQWNILHFCQUFxQjtRQUV2RCx1REFBdUQ7UUFDdkQsSUFBSWMsU0FBUztZQUNYRSxNQUFNRSxJQUFJLENBQUNKO1FBQ2I7UUFFQSxpRUFBaUU7UUFDakUsT0FBT0UsTUFBTUcsSUFBSSxDQUFDO0lBQ3BCO0FBQ0Y7QUFFQSxTQUFTRixNQUFNRyxNQUFNLEVBQUVDLFNBQVM7SUFFOUIsc0VBQXNFO0lBQ3RFLElBQUlDLElBQUksQ0FBRUYsT0FBT2YsTUFBTSxHQUFHLEtBQUssSUFBSztJQUVwQyxzRUFBc0U7SUFDdEUsSUFBSWlCLE1BQU0sS0FBTUYsTUFBTSxDQUFDLEVBQUUsS0FBSyxLQUFNO1FBQ2xDRSxJQUFJLEVBQUcsNENBQTRDOztJQUNyRDtJQUVBLE1BQU1DLFVBQVU7UUFDZEgsT0FBT0wsS0FBSyxDQUFDLEdBQUdPLEdBQUcsdUNBQXVDO0tBQzNEO0lBRUQsa0VBQWtFO0lBQ2xFLE1BQU9BLElBQUlGLE9BQU9mLE1BQU0sRUFBRWlCLEtBQUssRUFBRztRQUNoQ0MsUUFBUUwsSUFBSSxDQUFDRyxXQUFXRCxPQUFPSSxNQUFNLENBQUNGLEdBQUc7SUFDM0M7SUFFQSxPQUFPQztBQUNUO0FBR0EsMkNBQTJDO0FBQzNDLGtEQUFrRDtBQUNsRCxTQUFTRSxTQUFTSixTQUFTLEVBQUVuQixXQUFXO0lBQ3RDLE9BQU8sU0FBU0UsTUFBTTtRQUNwQixPQUFPTixZQUFZTSxRQUFRaUIsV0FBV25CO0lBQ3hDO0FBQ0Y7QUFFQXdCLE9BQU9DLE9BQU8sR0FBRzdCO0FBQ2pCNEIsdUJBQXVCLEdBQUdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWxkZXhkZXYtYmxvZy8uL25vZGVfbW9kdWxlcy9jb21tYS1udW1iZXIvaW5kZXguanM/YTc0YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gcmV0dXJuIGEgc3RyaW5nIHdpdGggdGhlIHByb3ZpZGVkIG51bWJlciBmb3JtYXR0ZWQgd2l0aCBjb21tYXMuXG4vLyBjYW4gc3BlY2lmeSBlaXRoZXIgYSBOdW1iZXIgb3IgYSBTdHJpbmcuXG5mdW5jdGlvbiBjb21tYU51bWJlcihpbnB1dE51bWJlciwgb3B0aW9uYWxTZXBhcmF0b3IsIG9wdGlvbmFsRGVjaW1hbENoYXIpIHtcblxuICAvLyBkZWZhdWx0IGBkZWNpbWFsQ2hhcmAgaXMgYSBwZXJpb2RcbiAgY29uc3QgZGVjaW1hbENoYXIgPSBvcHRpb25hbERlY2ltYWxDaGFyIHx8ICcuJ1xuXG4gIGxldCBzdHJpbmdOdW1iZXIgLy8gd2UgYXNzaWduIHRoaXMgaW4gdGhlIHN3aXRjaCBibG9jayBhbmQgbmVlZCBpdCBsYXRlci5cblxuICB7XG4gICAgbGV0IG51bWJlciAvLyB3ZSBhc3NpZ24gdGhpcyBpbiB0aGUgc3dpdGNoIGJsb2NrIGFuZCBuZWVkIGl0IHJpZ2h0IGFmdGVyLlxuXG4gICAgc3dpdGNoICh0eXBlb2YgaW5wdXROdW1iZXIpIHtcblxuICAgICAgY2FzZSAnc3RyaW5nJzpcblxuICAgICAgICAvLyBpZiB0aGVyZSBhcmVuJ3QgZW5vdWdoIGRpZ2l0cyB0byBuZWVkIHNlcGFyYXRvcnMgdGhlbiByZXR1cm4gaXRcbiAgICAgICAgLy8gTk9URTogc29tZSBudW1iZXJzIHdoaWNoIGFyZSB0b28gc21hbGwgd2lsbCBnZXQgcGFzc2VkIHRoaXNcbiAgICAgICAgLy8gICAgICAgd2hlbiB0aGV5IGhhdmUgZGVjaW1hbCB2YWx1ZXMgd2hpY2ggbWFrZSB0aGVtIHRvbyBsb25nIGhlcmUuXG4gICAgICAgIC8vICAgICAgIGJ1dCwgdGhlIG51bWJlciB2YWx1ZSBjaGVjayBhZnRlciB0aGlzIHN3aXRjaCB3aWxsIGNhdGNoIGl0LlxuICAgICAgICBpZiAoaW5wdXROdW1iZXIubGVuZ3RoIDwgKGlucHV0TnVtYmVyWzBdID09PSAnLScgPyA1IDogNCkpIHtcbiAgICAgICAgICByZXR1cm4gaW5wdXROdW1iZXJcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbWVtYmVyIGl0IGFzIGEgc3RyaW5nIGluIGBzdHJpbmdOdW1iZXJgIGFuZCBjb252ZXJ0IHRvIGEgTnVtYmVyXG4gICAgICAgIHN0cmluZ051bWJlciA9IGlucHV0TnVtYmVyXG5cbiAgICAgICAgLy8gaWYgdGhleSdyZSBub3QgdXNpbmcgdGhlIE5vZGUgc3RhbmRhcmQgZGVjaW1hbCBjaGFyIHRoZW4gcmVwbGFjZSBpdFxuICAgICAgICAvLyBiZWZvcmUgY29udmVydGluZy5cbiAgICAgICAgbnVtYmVyID0gTnVtYmVyKFxuICAgICAgICAgIChkZWNpbWFsQ2hhciAhPT0gJy4nKSA/IHN0cmluZ051bWJlci5yZXBsYWNlKGRlY2ltYWxDaGFyLCAnLicpIDogc3RyaW5nTnVtYmVyXG4gICAgICAgIClcbiAgICAgICAgYnJlYWtcblxuICAgICAgLy8gY29udmVydCB0byBhIHN0cmluZy5cbiAgICAgIC8vIE5PVEU6IGRvbid0IGNoZWNrIGlmIHRoZSBudW1iZXIgaXMgdG9vIHNtYWxsIGJlZm9yZSBjb252ZXJ0aW5nXG4gICAgICAvLyAgICAgICBiZWNhdXNlIHdlJ2xsIG5lZWQgdG8gcmV0dXJuIGBzdHJpbmdOdW1iZXJgIGFueXdheS5cbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIHN0cmluZ051bWJlciA9IFN0cmluZyhpbnB1dE51bWJlcilcbiAgICAgICAgbnVtYmVyICAgICAgID0gaW5wdXROdW1iZXJcbiAgICAgICAgLy8gY3JlYXRlIHRoZSBzdHJpbmcgdmVyc2lvbiB3aXRoIHRoZSBkZWNpbWFsQ2hhciB0aGV5IHNwZWNpZmllZC5cbiAgICAgICAgLy8gdGhpcyBtYXRjaGVzIHdoYXQgdGhlIGFib3ZlIGNhc2UgJ3N0cmluZycgcHJvZHVjZXMsXG4gICAgICAgIC8vIGFuZCwgZml4ZXMgdGhlIGJ1ZyAqbm90KiBkb2luZyB0aGlzIGNhdXNlZC5cbiAgICAgICAgaWYgKCcuJyAhPT0gZGVjaW1hbENoYXIgJiYgIU51bWJlci5pc0ludGVnZXIoaW5wdXROdW1iZXIpKSB7XG4gICAgICAgICAgc3RyaW5nTnVtYmVyID0gc3RyaW5nTnVtYmVyLnJlcGxhY2UoJy4nLCBkZWNpbWFsQ2hhcilcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuXG4gICAgICAvLyByZXR1cm4gaW52YWxpZCB0eXBlIGFzLWlzXG4gICAgICBkZWZhdWx0OiByZXR1cm4gaW5wdXROdW1iZXJcbiAgICB9XG5cbiAgICAvLyB3aGVuIGl0IGRvZXNuJ3QgbmVlZCBhIHNlcGFyYXRvciBvciBpc24ndCBhIG51bWJlciB0aGVuIHJldHVybiBpdFxuICAgIGlmICgoLTEwMDAgPCBudW1iZXIgJiYgbnVtYmVyIDwgMTAwMCkgfHwgaXNOYU4obnVtYmVyKSB8fCAhaXNGaW5pdGUobnVtYmVyKSkge1xuICAgICAgcmV0dXJuIHN0cmluZ051bWJlclxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICAvLyBzdHJpcCBvZmYgZGVjaW1hbCB2YWx1ZSB0byBhZGQgYmFjayBpbiBsYXRlclxuICAgIGNvbnN0IGRlY2ltYWxJbmRleCA9IHN0cmluZ051bWJlci5sYXN0SW5kZXhPZihkZWNpbWFsQ2hhcilcbiAgICBsZXQgZGVjaW1hbFxuICAgIGlmIChkZWNpbWFsSW5kZXggPiAtMSkge1xuICAgICAgZGVjaW1hbCA9IHN0cmluZ051bWJlci5zbGljZShkZWNpbWFsSW5kZXgpXG4gICAgICBzdHJpbmdOdW1iZXIgPSBzdHJpbmdOdW1iZXIuc2xpY2UoMCwgZGVjaW1hbEluZGV4KVxuICAgIH1cblxuICAgIC8vIGZpbmFsbHksIHBhcnNlIHRoZSBzdHJpbmcuIE5vdGUsIGRlZmF1bHQgJ3NlcGFyYXRvcicgaXMgYSBjb21tYS5cbiAgICBjb25zdCBwYXJ0cyA9IHBhcnNlKHN0cmluZ051bWJlciwgb3B0aW9uYWxTZXBhcmF0b3IgfHwgJywnKVxuXG4gICAgLy8gaWYgdGhlcmUncyBhIGRlY2ltYWwgdmFsdWUgdGhlbiBhZGQgaXQgdG8gdGhlIHBhcnRzLlxuICAgIGlmIChkZWNpbWFsKSB7Ly8gTk9URTogd2Ugc2xpY2VkKCkgaXQgb2ZmIGluY2x1ZGluZyB0aGUgZGVjaW1hbENoYXJcbiAgICAgIHBhcnRzLnB1c2goZGVjaW1hbClcbiAgICB9XG5cbiAgICAvLyBjb21iaW5lIGFsbCBwYXJ0cyBmb3IgdGhlIGZpbmFsIHN0cmluZyAobm90ZSwgaGFzIHNlcGFyYXRvcnMpLlxuICAgIHJldHVybiBwYXJ0cy5qb2luKCcnKVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlKHN0cmluZywgc2VwYXJhdG9yKSB7XG5cbiAgLy8gZmluZCBmaXJzdCBpbmRleCB0byBzcGxpdCB0aGUgc3RyaW5nIGF0ICh3aGVyZSAxc3Qgc2VwYXJhdG9yIGdvZXMpLlxuICBsZXQgaSA9ICgoc3RyaW5nLmxlbmd0aCAtIDEpICUgMykgKyAxXG5cbiAgLy8gYWJvdmUgY2FsY3VsYXRpb24gaXMgd3Jvbmcgd2hlbiBudW0gaXMgbmVnYXRpdmUgYW5kIGEgY2VydGFpbiBzaXplLlxuICBpZiAoaSA9PT0gMSAmJiAoc3RyaW5nWzBdID09PSAnLScpKSB7XG4gICAgaSA9IDQgIC8vIGV4YW1wbGU6IC0xMjMsNDU2LDc4OSAgc3RhcnQgYXQgNCwgbm90IDEuXG4gIH1cblxuICBjb25zdCBzdHJpbmdzID0gWyAvLyBob2xkcyB0aGUgc3RyaW5nIHBhcnRzXG4gICAgc3RyaW5nLnNsaWNlKDAsIGkpIC8vIGdyYWIgcGFydCBiZWZvcmUgdGhlIGZpcnN0IHNlcGFyYXRvclxuICBdXG5cbiAgLy8gc3BsaXQgcmVtYWluaW5nIHN0cmluZyBpbiBncm91cHMgb2YgMyB3aGVyZSBhIHNlcGFyYXRvciBiZWxvbmdzXG4gIGZvciAoOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgc3RyaW5ncy5wdXNoKHNlcGFyYXRvciwgc3RyaW5nLnN1YnN0cihpLCAzKSlcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdzXG59XG5cblxuLy8gY29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGN1cnJ5aW5nIHN0eWxlOlxuLy8gICBjb25zdCBmb3JtYXQgPSBjb21tYU51bWJlci5iaW5kV2l0aCgnLCcsICcuJylcbmZ1bmN0aW9uIGJpbmRXaXRoKHNlcGFyYXRvciwgZGVjaW1hbENoYXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG51bWJlcikge1xuICAgIHJldHVybiBjb21tYU51bWJlcihudW1iZXIsIHNlcGFyYXRvciwgZGVjaW1hbENoYXIpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb21tYU51bWJlclxubW9kdWxlLmV4cG9ydHMuYmluZFdpdGggPSBiaW5kV2l0aFxuIl0sIm5hbWVzIjpbImNvbW1hTnVtYmVyIiwiaW5wdXROdW1iZXIiLCJvcHRpb25hbFNlcGFyYXRvciIsIm9wdGlvbmFsRGVjaW1hbENoYXIiLCJkZWNpbWFsQ2hhciIsInN0cmluZ051bWJlciIsIm51bWJlciIsImxlbmd0aCIsIk51bWJlciIsInJlcGxhY2UiLCJTdHJpbmciLCJpc0ludGVnZXIiLCJpc05hTiIsImlzRmluaXRlIiwiZGVjaW1hbEluZGV4IiwibGFzdEluZGV4T2YiLCJkZWNpbWFsIiwic2xpY2UiLCJwYXJ0cyIsInBhcnNlIiwicHVzaCIsImpvaW4iLCJzdHJpbmciLCJzZXBhcmF0b3IiLCJpIiwic3RyaW5ncyIsInN1YnN0ciIsImJpbmRXaXRoIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/comma-number/index.js\n");

/***/ })

};
;